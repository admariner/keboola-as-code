package api

import (
	"fmt"
	"github.com/go-resty/resty/v2"
	"github.com/spf13/cast"
	"keboola-as-code/src/client"
	"keboola-as-code/src/model/remote"
	"time"
)

func (a *StorageApi) GetDefaultBranch() (*remote.Branch, error) {
	branches, err := a.ListBranches()
	if err != nil {
		return nil, err
	}

	for _, branch := range *branches {
		if branch.IsDefault {
			return branch, nil
		}
	}

	return nil, fmt.Errorf("default branch not found")
}

func (a *StorageApi) GetBranch(branchId int) (*remote.Branch, error) {
	response := a.GetBranchRequest(branchId).Send().Response()
	if response.HasResult() {
		return response.Result().(*remote.Branch), nil
	}
	return nil, response.Error()
}

func (a *StorageApi) CreateBranch(branch *remote.Branch) (*remote.Job, error) {
	response := a.CreateBranchRequest(branch).Send().Response()
	if response.HasResult() {
		return response.Result().(*remote.Job), nil
	}
	return nil, response.Error()
}

func (a *StorageApi) ListBranches() (*[]*remote.Branch, error) {
	response := a.ListBranchesRequest().Send().Response()
	if response.HasResult() {
		return response.Result().(*[]*remote.Branch), nil
	}
	return nil, response.Error()
}

func (a *StorageApi) DeleteBranch(branchId int) (*remote.Job, error) {
	response := a.DeleteBranchRequest(branchId).Send().Response()
	if response.HasResult() {
		return response.Result().(*remote.Job), nil
	}
	return nil, response.Error()
}

// GetBranchRequest https://keboola.docs.apiary.io/#reference/development-branches/branch-manipulation/branch-detail
func (a *StorageApi) GetBranchRequest(branchId int) *client.Request {
	branch := &remote.Branch{}
	return a.
		Request(resty.MethodGet, fmt.Sprintf("dev-branches/%d", branchId)).
		SetResult(branch)
}

// CreateBranchRequest https://keboola.docs.apiary.io/#reference/development-branches/branches/create-branch
func (a *StorageApi) CreateBranchRequest(branch *remote.Branch) *client.Request {
	job := &remote.Job{}
	// Id is autogenerated
	if branch.Id != 0 {
		panic("branch id is set but it should be auto-generated")
	}

	// Default branch cannot be created
	if branch.IsDefault {
		panic("default branch still exists, cannot be created")
	}

	// Create request
	request := a.
		Request(resty.MethodPost, "dev-branches").
		SetHeader("Content-Type", "application/x-www-form-urlencoded").
		SetMultipartFormData(map[string]string{
			"name":        branch.Name,
			"description": branch.Description,
		}).
		SetResult(job).
		OnSuccess(waitForSuccessJob(a, job, func(response *client.Response) *client.Response {
			// Set branch id from job results
			branch.Id = cast.ToInt(job.Results["id"])
			return response
		}))

	return request
}

// ListBranchesRequest https://keboola.docs.apiary.io/#reference/development-branches/branches/list-branches
func (a *StorageApi) ListBranchesRequest() *client.Request {
	branches := make([]*remote.Branch, 0)
	return a.
		Request(resty.MethodGet, "dev-branches").
		SetResult(&branches)

}

// DeleteBranchRequest https://keboola.docs.apiary.io/#reference/development-branches/branch-manipulation/delete-branch
func (a *StorageApi) DeleteBranchRequest(branchId int) *client.Request {
	job := &remote.Job{}
	return a.Request(resty.MethodDelete, fmt.Sprintf("dev-branches/%d", branchId)).
		SetResult(job).
		OnSuccess(waitForSuccessJob(a, job, nil))
}

func waitForSuccessJob(a *StorageApi, job *remote.Job, onJobSuccess client.ResponseCallback) client.ResponseCallback {
	// Check job
	backoff := a.createBackoff()
	var checkJob client.ResponseCallback
	checkJob = func(response *client.Response) *client.Response {
		if job.Status == "success" {
			if onJobSuccess != nil {
				onJobSuccess(response)
			}
			return response
		} else if job.Status == "error" {
			return response.SetError(fmt.Errorf("create branch job failed: %v", job.Results))
		}

		// Wait and check again
		delay := backoff.NextBackOff()
		if delay == backoff.Stop {
			return response.SetError(fmt.Errorf("timeout: checking waiting storage job - create branch"))
		}
		time.Sleep(delay)

		// Try again
		request := a.GetJobRequest(job.Id).SetResult(job).OnSuccess(checkJob)
		response.Sender().Send(request)
		return response
	}
	return checkJob
}
