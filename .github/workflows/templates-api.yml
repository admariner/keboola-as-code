name: 'Provisioning: Templates API'
on:
  pull_request:
    paths:
      - provisioning/templates-api/**

env:
  MINIKUBE_PROFILE: templates-api
  KUBERNETES_NAMESPACE: templates-api
  ETCD_ENDPOINT: templates-api-etcd-headless.templates-api.svc.cluster.local:2379

defaults:
  run:
    working-directory: provisioning/templates-api

jobs:
  test:
    name: 'Test'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.pull_request.head.ref }}
      - name: Start MiniKube
        run: ./start_minikube.sh
      - name: Set Kubernetes namespace
        run: kubectl config set-context --current "--namespace=$KUBERNETES_NAMESPACE"
      - name: Checkout BASE branch
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.pull_request.base.ref }}
      - name: Deploy the previous version, from the BASE branch
        run: ./deploy_local.sh
      - name: Checkout HEAD branch
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.pull_request.head.ref }}
      - name: Deploy the new version, from the HEAD branch
        run: ./deploy_local.sh
      - name: Check deployment of the etcd
        if: always()
        run: kubectl rollout status sts/templates-api-etcd
      - name: Check deployment of the API
        if: always()
        run: kubectl rollout status deployment/templates-api
      - name: Check access to the etcd from a client
        if: always()
        run: |
          set -Eeuo pipefail
          export ETCD_ROOT_PASSWORD=$(kubectl get secret templates-api-etcd -o jsonpath="{.data.etcd-root-password}" 2>/dev/null | base64 -d)
          kubectl run --attach --rm --restart=Never check-etcd-client \
            --image docker.io/bitnami/etcd \
            --labels="templates-api-etcd-client=true" \
            --env="ETCD_ROOT_PASSWORD=$ETCD_ROOT_PASSWORD" \
            --env="ETCDCTL_ENDPOINTS=$ETCD_ENDPOINT" \
            --command -- etcdctl --user root:$ETCD_ROOT_PASSWORD put /message Hello
      - name: Check access to the etcd from the DataDog Agent
        if: always()
        run: |
          set -Eeuo pipefail
          kubectl create namespace datadog
          kubectl run --attach --rm --restart=Never check-etcd-other-data-dog \
          --namespace datadog \
          --image docker.io/alpine/curl \
          --labels="app=datadog-agent" \
          --env="ETCD_ENDPOINT=$ETCD_ENDPOINT" \
          --command -- sh -c "set -eo pipefail; curl -f -L --max-time 15 "$ETCD_ENDPOINT/metrics" | tail"
      - name: Check forbidden access to the etcd from other places
        if: always()
        run: |
          set -Eeuo pipefail
          if kubectl run --attach --rm --restart=Never check-etcd-other \
            --image docker.io/alpine/curl \
            --env="ETCD_ENDPOINT=$ETCD_ENDPOINT" \
            --command -- sh -c "set -eo pipefail; curl -f -L --max-time 15 "$ETCD_ENDPOINT/metrics" | tail"; then
            echo "The command did not fail, but it should have."
            exit 1
          else
            echo "The command failed, OK."
            exit 0
          fi
      - name: Check API response
        if: always()
        run: |
          curl --fail -L -s "$(minikube service --url templates-api)"
      - name: Test etcd defragmentation cron job
        if: always()
        run: |
          set -Eeuo pipefail
          kubectl create job --from=cronjob/templates-api-etcd-defrag test-defrag-job
          if kubectl wait --for=condition=complete --timeout=30s job/test-defrag-job; then
            echo "The job succeed, logs:"
            kubectl logs --selector="job-name=test-defrag-job"
            exit 0
          else
            echo "The job failed, logs:"
            kubectl logs --selector="job-name=test-defrag-job"
            exit 1
          fi
