name: 'K8S: Templates API'

on:
  workflow_call:
  pull_request:
    paths:
      - provisioning/templates-api/**
      - provisioning/common/etcd/**

env:
  MINIKUBE_PROFILE: templates-api
  KUBERNETES_NAMESPACE: templates-api
  API_RELEASE_NAME: templates-api
  ETCD_RELEASE_NAME: templates-api-etcd
  ETCD_ENDPOINT: templates-api-etcd-headless.templates-api.svc.cluster.local:2379

defaults:
  run:
    working-directory: provisioning/templates-api

jobs:
  test:
    name: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.pull_request.head.ref }}

      - name: Create artifacts directory
        run: mkdir -p /tmp/artifacts

      - name: Install gron tool
        run: |
          url="https://github.com/tomnomnom/gron/releases/download/v0.7.1/gron-linux-amd64-0.7.1.tgz"
          curl -L "$url" | tar -xz -C /usr/local/bin

      - name: Start MiniKube
        run: ./start_minikube.sh

      - name: Set Kubernetes namespace
        run: kubectl config set-context --current "--namespace=$KUBERNETES_NAMESPACE"

      - name: Checkout BASE branch
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.pull_request.base.ref }}

      - name: Deploy the old version, from the BASE branch
        continue-on-error: true
        run: ./deploy_local.sh

      - name: Dump the old version (for diff)
        continue-on-error: true
        run: |
          set -Eeuo pipefail
          # Wait for pod startup/termination
          sleep 10
          # List objects
          kubectl get all --namespace templates-api
          # Dump objects (kubectl get all doesn't return all types)
          kubectl get all,configmaps,pdb --ignore-not-found --sort-by='{.metadata.name}' --output json \
            > /tmp/artifacts/test-k8s-state.old.json
      - name: Checkout HEAD branch
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.pull_request.head.ref }}

      - name: Deploy the new version, from the HEAD branch
        run: ./deploy_local.sh

      - name: Dump the new version (for diff)
        continue-on-error: true
        run: |
          set -Eeuo pipefail
          # Delete empty old replicas
          kubectl delete --namespace templates-api $(kubectl get all --namespace templates-api | grep replicaset.apps | awk '{if ($2 + $3 + $4 == 0) print $1}')
          # Wait for pod startup/termination
          sleep 10
          # List objects
          kubectl get all --namespace templates-api
          # Dump objects (kubectl get all doesn't return all types)
          kubectl get all,configmaps,pdb --ignore-not-found --sort-by='{.metadata.name}' --output json \
            > /tmp/artifacts/test-k8s-state.new.json
      - name: Check deployment of the etcd
        if: always()
        run: kubectl rollout status "sts/$ETCD_RELEASE_NAME"

      - name: Check deployment of the API
        if: always()
        run: kubectl rollout status "deployment/$API_RELEASE_NAME"

      - name: Check access to the etcd from a client
        if: always()
        run: |
          set -Eeuo pipefail
          export ETCD_ROOT_PASSWORD=$(kubectl get secret "$ETCD_RELEASE_NAME" -o jsonpath="{.data.etcd-root-password}" 2>/dev/null | base64 -d)
          kubectl run --attach --rm --restart=Never check-etcd-client \
            --image docker.io/bitnami/etcd \
            --labels="${ETCD_RELEASE_NAME}-client=true" \
            --env="ETCD_ROOT_PASSWORD=$ETCD_ROOT_PASSWORD" \
            --env="ETCDCTL_ENDPOINTS=$ETCD_ENDPOINT" \
            --command -- etcdctl --user root:$ETCD_ROOT_PASSWORD put /message Hello

      - name: Check access to the etcd from the DataDog Agent
        if: always()
        run: |
          set -Eeuo pipefail
          kubectl create namespace datadog
          kubectl run --attach --rm --restart=Never check-etcd-other-data-dog \
          --namespace datadog \
          --image docker.io/alpine/curl \
          --labels="app=datadog-agent" \
          --env="ETCD_ENDPOINT=$ETCD_ENDPOINT" \
          --command -- sh -c "set -eo pipefail; curl -f -L --max-time 5 "$ETCD_ENDPOINT/metrics" | tail"

      - name: Check forbidden access to the etcd from other places
        if: always()
        run: |
          set -Eeuo pipefail
          if kubectl run --attach --rm --restart=Never check-etcd-other \
            --image docker.io/alpine/curl \
            --env="ETCD_ENDPOINT=$ETCD_ENDPOINT" \
            --command -- sh -c "set -eo pipefail; curl -f -L --max-time 5 "$ETCD_ENDPOINT/metrics" | tail"; then
            echo "The command did not fail, but it should have."
            exit 1
          else
            echo "The command failed, OK."
            exit 0
          fi

      - name: Check API response
        if: always()
        run: curl --fail -L -s "$(minikube service --url $API_RELEASE_NAME --namespace $KUBERNETES_NAMESPACE)"

      - name: Test etcd defragmentation cron job
        if: always()
        run: |
          set -Eeuo pipefail
          
          # Create a job from the cron job
          kubectl create job "--from=cronjob/${ETCD_RELEASE_NAME}-defrag" test-defrag-job
          
          # Wait for the job
          if kubectl wait --for=condition=complete --timeout=30s job/test-defrag-job; then
            echo "The job succeed, logs:"
            kubectl logs --selector="job-name=test-defrag-job"
            exit 0
          else
            echo "The job failed, logs:"
            kubectl logs --selector="job-name=test-defrag-job"
            exit 1
          fi

      - name: Prepare inputs for the diff
        if: always()
        run: |
          set -Eeuo pipefail
          
          process() {
            suffix="$1"
            # Get paths
            prefix="/tmp/artifacts/test-k8s-state.$suffix"
            in="$prefix.json"
            out="$prefix.processed.json"
            outKV="$prefix.processed.json.kv"
            
            # Get ReplicaSet hashes, for example "pod-template-hash: 6749584fd9" -> "6749584fd9"
            hashes=$(cat "$in" | jq '.items[] | select(.kind == "ReplicaSet") | .metadata.labels."pod-template-hash"' --raw-output)
            printf "Found ReplicaSet hashes is $suffix state:\n%s\n" $hashes
            
            # Replace ReplicaSet hashes, for example "api-6749584fd9-m7q5c" -> "api-<hash>"
            cp "$in" "$out" 
            echo $hashes | xargs -I '{}' sed -i -E 's/-{}(-[a-zA-Z0-9]+)?/-<hash>/g' "$out"
            echo $hashes | xargs -I '{}' sed -i -E 's/{}/<hash>/g' "$out"
            
            # Convert to key=value pairs
            gron "$out" > "$outKV" 
          
            # Regexps to remove dynamic values
            keyEndsWith="time|timestamp|uid|at|ip|release|hash|tags|((^api)version)|revision|generation|resourceVersion"
            keyContains="\.status|\.metadata.annotations|\.volumeMounts\[[0-9]+\]\.name|\.volumes\[[0-9]+\]\.name|last-applied|revision-hash"
            regexp="(($keyEndsWith) =)|(($keyContains).* =)"
          
            # Remove dynamic values
            cp "$outKV" "$outKV.original1"  
            sed -E "/$regexp/Id" -i "$outKV"
            echo "Ignored dynamic lines:"
            diff --color=always -u0 "$outKV.original1" "$outKV" || true
          
            # Replace array indexes json.items[123] by <kind/name>
            cp "$outKV" "$outKV.original2"  
            toName=$(sed -n -E 's/^(json\.items\[[0-9]+\])\.metadata\.name = "([^"]+)";/\1|\2/p' "$outKV")
            toKind=$(sed -n -E 's/^(json\.items\[[0-9]+\])\.kind = "([^"]+)";/\1|\2/p' "$outKV")
            toKindAndName=$(echo -e "$toKind\n$toName" | awk 'BEGIN { FS=OFS=SUBSEP="|"}{arr[$1]=arr[$1] (length(arr[$1])>1?"/":"") $2 }END {for (i in arr) print i " <" arr[i] ">"}')
            printf "Item index -> kind and name:\n%s\n" "$toKindAndName"
            echo "$toKindAndName" | xargs -L 2 printf 's:\Q%s\E:%s:\0' | xargs -0 -I '{}' perl -pe '{}' -i "$outKV"
          
            # Sort file
            sort -o "$outKV" "$outKV"
          }
          
          process old
          process new

      - name: Diff the old and the new Kubernetes state
        if: always()
        run: |
          set -Eeuo pipefail
          
          # Diff JSON states
          (diff --color=always -u0 \
            /tmp/artifacts/test-k8s-state.old.processed.json.kv \
            /tmp/artifacts/test-k8s-state.new.processed.json.kv \
          || true) | tee /tmp/artifacts/test-k8s-state.diff
          
          # Remove ANSI sequences
          sed -e 's/\x1b\[[0-9;]*m//g' -i /tmp/artifacts/test-k8s-state.diff || true
          
          # Prepare comment message
          echo -e "### Templates API Kubernetes Diff [CI]\n\n" >> /tmp/artifacts/test-k8s-state.diff.message
          echo -e "Between `base` ${{ github.event.pull_request.base.sha }} :arrow_left:  `head` ${{ github.event.pull_request.head.sha }}.\n\n" >> /tmp/artifacts/test-k8s-state.diff.message
          echo -e "<details>\n<summary>Expand</summary>\n\n\`\`\`diff\n" >> /tmp/artifacts/test-k8s-state.diff.message
          cat /tmp/artifacts/test-k8s-state.diff >> /tmp/artifacts/test-k8s-state.diff.message
          echo -e "\n\`\`\`\n</details>" >> /tmp/artifacts/test-k8s-state.diff.message

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: test-k8s-state
          path: /tmp/artifacts

      - name: Send PR comment
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: "${{ env.KUBERNETES_NAMESPACE }}-kubernetes-state-diff"
          recreate: true
          path: /tmp/artifacts/test-k8s-state.diff.message
