package diskwriter_test

import (
	"context"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/keboola/keboola-as-code/internal/pkg/service/common/servicectx"
	"github.com/keboola/keboola-as-code/internal/pkg/service/stream/dependencies"
	"github.com/keboola/keboola-as-code/internal/pkg/service/stream/storage/level/local/diskwriter"
	"github.com/keboola/keboola-as-code/internal/pkg/service/stream/storage/level/local/volume/model"
	"github.com/keboola/keboola-as-code/internal/pkg/utils/errors"
)

func TestOpenVolumes(t *testing.T) {
	t.Parallel()

	ctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)
	defer cancel()

	process := servicectx.New()
	d, mock := dependencies.NewMockedStorageScope(t, ctx)

	// Create volumes directories
	volumesPath := t.TempDir()
	require.NoError(t, os.MkdirAll(filepath.Join(volumesPath, "hdd", "1", "slices"), 0o750))
	require.NoError(t, os.WriteFile(filepath.Join(volumesPath, "hdd", "some-file"), nil, 0o640))
	require.NoError(t, os.MkdirAll(filepath.Join(volumesPath, "HDD", "2"), 0o750))
	require.NoError(t, os.MkdirAll(filepath.Join(volumesPath, "hdd", "3"), 0o750))
	require.NoError(t, os.MkdirAll(filepath.Join(volumesPath, "SSD", "1"), 0o750))
	require.NoError(t, os.MkdirAll(filepath.Join(volumesPath, "ssd", "2"), 0o750))

	// Created also some drained volume
	require.NoError(t, os.MkdirAll(filepath.Join(volumesPath, "drained", "1"), 0o750))
	require.NoError(t, os.WriteFile(filepath.Join(volumesPath, "drained", "1", diskwriter.DrainFile), []byte{}, 0o640))

	// Only two volumes has volume ID file
	require.NoError(t, os.WriteFile(filepath.Join(volumesPath, "hdd", "1", model.IDFile), []byte("HDD_1"), 0o640))
	require.NoError(t, os.WriteFile(filepath.Join(volumesPath, "HDD", "2", model.IDFile), []byte("HDD_2"), 0o640))

	// Start volumes opening
	var err error
	var volumes *diskwriter.Volumes
	done := make(chan struct{})
	go func() {
		defer close(done)
		volumes, err = diskwriter.OpenVolumes(ctx, d, volumesPath, mock.TestConfig().Storage.Level.Local.Writer)
		require.NoError(t, err)
	}()

	// Wait for opening
	// Remaining volume ID files should be generated by the writer.Open.
	select {
	case <-done:
	// ok
	case <-time.After(5 * time.Second):
		assert.Fail(t, "timeout")
	}

	// Check opened volumes
	assert.Len(t, volumes.Collection().All(), 6)
	assert.Empty(t, volumes.Collection().VolumeByType("foo"))
	assert.Len(t, volumes.Collection().VolumeByType("hdd"), 3)
	assert.Len(t, volumes.Collection().VolumeByType("ssd"), 2)
	assert.Len(t, volumes.Collection().VolumeByType("drained"), 1)
	for _, id := range []model.ID{"HDD_1", "HDD_2"} {
		vol, err := volumes.Collection().Volume(id)
		assert.NotNil(t, vol)
		require.NoError(t, err)
	}
	for _, path := range []string{
		filepath.Join(volumesPath, "hdd", "3", model.IDFile),
		filepath.Join(volumesPath, "SSD", "1", model.IDFile),
		filepath.Join(volumesPath, "ssd", "2", model.IDFile),
		filepath.Join(volumesPath, "drained", "1", model.IDFile),
	} {
		content, err := os.ReadFile(path)
		require.NoError(t, err)
		vol, err := volumes.Collection().Volume(model.ID(content))
		assert.NotNil(t, vol)
		require.NoError(t, err)
	}

	// Close volumes
	process.Shutdown(ctx, errors.New("bye bye"))
	process.WaitForShutdown()
}
