package volume

import (
	"context"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/benbjohnson/clock"
	"github.com/stretchr/testify/assert"

	"github.com/keboola/keboola-as-code/internal/pkg/log"
	"github.com/keboola/keboola-as-code/internal/pkg/service/common/servicectx"
	volume "github.com/keboola/keboola-as-code/internal/pkg/service/stream/storage/level/local/volume/model"
	"github.com/keboola/keboola-as-code/internal/pkg/service/stream/storage/level/local/writer"
	"github.com/keboola/keboola-as-code/internal/pkg/utils/errors"
)

func TestOpenVolumes(t *testing.T) {
	t.Parallel()

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	logger := log.NewDebugLogger()
	clk := clock.New()
	process := servicectx.New()
	wrCfg := writer.NewConfig()

	// Create volumes directories
	volumesPath := t.TempDir()
	assert.NoError(t, os.MkdirAll(filepath.Join(volumesPath, "hdd", "1", "slices"), 0o750))
	assert.NoError(t, os.WriteFile(filepath.Join(volumesPath, "hdd", "some-file"), nil, 0o640))
	assert.NoError(t, os.MkdirAll(filepath.Join(volumesPath, "HDD", "2"), 0o750))
	assert.NoError(t, os.MkdirAll(filepath.Join(volumesPath, "hdd", "3"), 0o750))
	assert.NoError(t, os.MkdirAll(filepath.Join(volumesPath, "SSD", "1"), 0o750))
	assert.NoError(t, os.MkdirAll(filepath.Join(volumesPath, "ssd", "2"), 0o750))

	// Created also some drained volume
	assert.NoError(t, os.MkdirAll(filepath.Join(volumesPath, "drained", "1"), 0o750))
	assert.NoError(t, os.WriteFile(filepath.Join(volumesPath, "drained", "1", drainFile), []byte{}, 0o640))

	// Only two volumes has volume ID file
	assert.NoError(t, os.WriteFile(filepath.Join(volumesPath, "hdd", "1", volume.IDFile), []byte("HDD_1"), 0o640))
	assert.NoError(t, os.WriteFile(filepath.Join(volumesPath, "HDD", "2", volume.IDFile), []byte("HDD_2"), 0o640))

	// Start volumes opening
	var err error
	var volumes *Volumes
	done := make(chan struct{})
	go func() {
		defer close(done)
		volumes, err = OpenVolumes(ctx, logger, clk, process, "my-node", volumesPath, wrCfg)
		assert.NoError(t, err)
	}()

	// Wait for opening
	// Remaining volume ID files should be generated by the writer.Open.
	select {
	case <-done:
	// ok
	case <-time.After(5 * time.Second):
		assert.Fail(t, "timeout")
	}

	// Check opened volumes
	assert.Len(t, volumes.Collection().All(), 6)
	assert.Len(t, volumes.Collection().VolumeByType("foo"), 0)
	assert.Len(t, volumes.Collection().VolumeByType("hdd"), 3)
	assert.Len(t, volumes.Collection().VolumeByType("ssd"), 2)
	assert.Len(t, volumes.Collection().VolumeByType("drained"), 1)
	for _, id := range []volume.ID{"HDD_1", "HDD_2"} {
		vol, err := volumes.Collection().Volume(id)
		assert.NotNil(t, vol)
		assert.NoError(t, err)
	}
	for _, path := range []string{
		filepath.Join(volumesPath, "hdd", "3", volume.IDFile),
		filepath.Join(volumesPath, "SSD", "1", volume.IDFile),
		filepath.Join(volumesPath, "ssd", "2", volume.IDFile),
		filepath.Join(volumesPath, "drained", "1", volume.IDFile),
	} {
		content, err := os.ReadFile(path)
		assert.NoError(t, err)
		vol, err := volumes.Collection().Volume(volume.ID(content))
		assert.NotNil(t, vol)
		assert.NoError(t, err)
	}

	// Close volumes
	process.Shutdown(ctx, errors.New("bye bye"))
	process.WaitForShutdown()
}
