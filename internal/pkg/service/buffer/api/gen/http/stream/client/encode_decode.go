// Code generated by goa v3.14.6, DO NOT EDIT.
//
// stream HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/keboola/keboola-as-code/api/buffer --output
// ./internal/pkg/service/buffer/api

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"

	stream "github.com/keboola/keboola-as-code/internal/pkg/service/buffer/api/gen/stream"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// BuildAPIRootIndexRequest instantiates a HTTP request object with method and
// path set to call the "stream" service "ApiRootIndex" endpoint
func (c *Client) BuildAPIRootIndexRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: APIRootIndexStreamPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("stream", "ApiRootIndex", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeAPIRootIndexResponse returns a decoder for responses returned by the
// stream ApiRootIndex endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeAPIRootIndexResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusMovedPermanently:
			return nil, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("stream", "ApiRootIndex", resp.StatusCode, string(body))
		}
	}
}

// BuildAPIVersionIndexRequest instantiates a HTTP request object with method
// and path set to call the "stream" service "ApiVersionIndex" endpoint
func (c *Client) BuildAPIVersionIndexRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: APIVersionIndexStreamPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("stream", "ApiVersionIndex", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeAPIVersionIndexResponse returns a decoder for responses returned by
// the stream ApiVersionIndex endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeAPIVersionIndexResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body APIVersionIndexResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "ApiVersionIndex", err)
			}
			err = ValidateAPIVersionIndexResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "ApiVersionIndex", err)
			}
			res := NewAPIVersionIndexServiceDetailOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("stream", "ApiVersionIndex", resp.StatusCode, string(body))
		}
	}
}

// BuildHealthCheckRequest instantiates a HTTP request object with method and
// path set to call the "stream" service "HealthCheck" endpoint
func (c *Client) BuildHealthCheckRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: HealthCheckStreamPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("stream", "HealthCheck", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeHealthCheckResponse returns a decoder for responses returned by the
// stream HealthCheck endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeHealthCheckResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "HealthCheck", err)
			}
			return body, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("stream", "HealthCheck", resp.StatusCode, string(body))
		}
	}
}

// BuildCreateSourceRequest instantiates a HTTP request object with method and
// path set to call the "stream" service "CreateSource" endpoint
func (c *Client) BuildCreateSourceRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		branchID string
	)
	{
		p, ok := v.(*stream.CreateSourcePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("stream", "CreateSource", "*stream.CreateSourcePayload", v)
		}
		branchID = string(p.BranchID)
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateSourceStreamPath(branchID)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("stream", "CreateSource", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateSourceRequest returns an encoder for requests sent to the stream
// CreateSource server.
func EncodeCreateSourceRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*stream.CreateSourcePayload)
		if !ok {
			return goahttp.ErrInvalidType("stream", "CreateSource", "*stream.CreateSourcePayload", v)
		}
		{
			head := p.StorageAPIToken
			req.Header.Set("X-StorageApi-Token", head)
		}
		body := NewCreateSourceRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("stream", "CreateSource", err)
		}
		return nil
	}
}

// DecodeCreateSourceResponse returns a decoder for responses returned by the
// stream CreateSource endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeCreateSourceResponse may return the following errors:
//   - "stream.sourceAlreadyExists" (type *stream.GenericError): http.StatusConflict
//   - "stream.resourceLimitReached" (type *stream.GenericError): http.StatusUnprocessableEntity
//   - error: internal error
func DecodeCreateSourceResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusAccepted:
			var (
				body CreateSourceResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "CreateSource", err)
			}
			err = ValidateCreateSourceResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "CreateSource", err)
			}
			res := NewCreateSourceTaskAccepted(&body)
			return res, nil
		case http.StatusConflict:
			var (
				body CreateSourceStreamSourceAlreadyExistsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "CreateSource", err)
			}
			err = ValidateCreateSourceStreamSourceAlreadyExistsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "CreateSource", err)
			}
			return nil, NewCreateSourceStreamSourceAlreadyExists(&body)
		case http.StatusUnprocessableEntity:
			var (
				body CreateSourceStreamResourceLimitReachedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "CreateSource", err)
			}
			err = ValidateCreateSourceStreamResourceLimitReachedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "CreateSource", err)
			}
			return nil, NewCreateSourceStreamResourceLimitReached(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("stream", "CreateSource", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateSourceRequest instantiates a HTTP request object with method and
// path set to call the "stream" service "UpdateSource" endpoint
func (c *Client) BuildUpdateSourceRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		branchID string
		sourceID string
	)
	{
		p, ok := v.(*stream.UpdateSourcePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("stream", "UpdateSource", "*stream.UpdateSourcePayload", v)
		}
		branchID = string(p.BranchID)
		sourceID = string(p.SourceID)
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateSourceStreamPath(branchID, sourceID)}
	req, err := http.NewRequest("PATCH", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("stream", "UpdateSource", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateSourceRequest returns an encoder for requests sent to the stream
// UpdateSource server.
func EncodeUpdateSourceRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*stream.UpdateSourcePayload)
		if !ok {
			return goahttp.ErrInvalidType("stream", "UpdateSource", "*stream.UpdateSourcePayload", v)
		}
		{
			head := p.StorageAPIToken
			req.Header.Set("X-StorageApi-Token", head)
		}
		body := NewUpdateSourceRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("stream", "UpdateSource", err)
		}
		return nil
	}
}

// DecodeUpdateSourceResponse returns a decoder for responses returned by the
// stream UpdateSource endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeUpdateSourceResponse may return the following errors:
//   - "stream.sourceNotFound" (type *stream.GenericError): http.StatusNotFound
//   - error: internal error
func DecodeUpdateSourceResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateSourceResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "UpdateSource", err)
			}
			err = ValidateUpdateSourceResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "UpdateSource", err)
			}
			res := NewUpdateSourceSourceOK(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body UpdateSourceStreamSourceNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "UpdateSource", err)
			}
			err = ValidateUpdateSourceStreamSourceNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "UpdateSource", err)
			}
			return nil, NewUpdateSourceStreamSourceNotFound(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("stream", "UpdateSource", resp.StatusCode, string(body))
		}
	}
}

// BuildListSourcesRequest instantiates a HTTP request object with method and
// path set to call the "stream" service "ListSources" endpoint
func (c *Client) BuildListSourcesRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		branchID string
	)
	{
		p, ok := v.(*stream.ListSourcesPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("stream", "ListSources", "*stream.ListSourcesPayload", v)
		}
		branchID = string(p.BranchID)
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListSourcesStreamPath(branchID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("stream", "ListSources", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListSourcesRequest returns an encoder for requests sent to the stream
// ListSources server.
func EncodeListSourcesRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*stream.ListSourcesPayload)
		if !ok {
			return goahttp.ErrInvalidType("stream", "ListSources", "*stream.ListSourcesPayload", v)
		}
		{
			head := p.StorageAPIToken
			req.Header.Set("X-StorageApi-Token", head)
		}
		return nil
	}
}

// DecodeListSourcesResponse returns a decoder for responses returned by the
// stream ListSources endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeListSourcesResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListSourcesResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "ListSources", err)
			}
			err = ValidateListSourcesResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "ListSources", err)
			}
			res := NewListSourcesSourcesListOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("stream", "ListSources", resp.StatusCode, string(body))
		}
	}
}

// BuildGetSourceRequest instantiates a HTTP request object with method and
// path set to call the "stream" service "GetSource" endpoint
func (c *Client) BuildGetSourceRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		branchID string
		sourceID string
	)
	{
		p, ok := v.(*stream.GetSourcePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("stream", "GetSource", "*stream.GetSourcePayload", v)
		}
		branchID = string(p.BranchID)
		sourceID = string(p.SourceID)
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetSourceStreamPath(branchID, sourceID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("stream", "GetSource", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetSourceRequest returns an encoder for requests sent to the stream
// GetSource server.
func EncodeGetSourceRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*stream.GetSourcePayload)
		if !ok {
			return goahttp.ErrInvalidType("stream", "GetSource", "*stream.GetSourcePayload", v)
		}
		{
			head := p.StorageAPIToken
			req.Header.Set("X-StorageApi-Token", head)
		}
		return nil
	}
}

// DecodeGetSourceResponse returns a decoder for responses returned by the
// stream GetSource endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeGetSourceResponse may return the following errors:
//   - "stream.sourceNotFound" (type *stream.GenericError): http.StatusNotFound
//   - error: internal error
func DecodeGetSourceResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetSourceResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "GetSource", err)
			}
			err = ValidateGetSourceResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "GetSource", err)
			}
			res := NewGetSourceSourceOK(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body GetSourceStreamSourceNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "GetSource", err)
			}
			err = ValidateGetSourceStreamSourceNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "GetSource", err)
			}
			return nil, NewGetSourceStreamSourceNotFound(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("stream", "GetSource", resp.StatusCode, string(body))
		}
	}
}

// BuildDeleteSourceRequest instantiates a HTTP request object with method and
// path set to call the "stream" service "DeleteSource" endpoint
func (c *Client) BuildDeleteSourceRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		branchID string
		sourceID string
	)
	{
		p, ok := v.(*stream.DeleteSourcePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("stream", "DeleteSource", "*stream.DeleteSourcePayload", v)
		}
		branchID = string(p.BranchID)
		sourceID = string(p.SourceID)
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeleteSourceStreamPath(branchID, sourceID)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("stream", "DeleteSource", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeleteSourceRequest returns an encoder for requests sent to the stream
// DeleteSource server.
func EncodeDeleteSourceRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*stream.DeleteSourcePayload)
		if !ok {
			return goahttp.ErrInvalidType("stream", "DeleteSource", "*stream.DeleteSourcePayload", v)
		}
		{
			head := p.StorageAPIToken
			req.Header.Set("X-StorageApi-Token", head)
		}
		return nil
	}
}

// DecodeDeleteSourceResponse returns a decoder for responses returned by the
// stream DeleteSource endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeDeleteSourceResponse may return the following errors:
//   - "stream.sourceNotFound" (type *stream.GenericError): http.StatusNotFound
//   - error: internal error
func DecodeDeleteSourceResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			return nil, nil
		case http.StatusNotFound:
			var (
				body DeleteSourceStreamSourceNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "DeleteSource", err)
			}
			err = ValidateDeleteSourceStreamSourceNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "DeleteSource", err)
			}
			return nil, NewDeleteSourceStreamSourceNotFound(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("stream", "DeleteSource", resp.StatusCode, string(body))
		}
	}
}

// BuildGetSourceSettingsRequest instantiates a HTTP request object with method
// and path set to call the "stream" service "GetSourceSettings" endpoint
func (c *Client) BuildGetSourceSettingsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		branchID string
		sourceID string
	)
	{
		p, ok := v.(*stream.GetSourceSettingsPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("stream", "GetSourceSettings", "*stream.GetSourceSettingsPayload", v)
		}
		branchID = string(p.BranchID)
		sourceID = string(p.SourceID)
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetSourceSettingsStreamPath(branchID, sourceID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("stream", "GetSourceSettings", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetSourceSettingsRequest returns an encoder for requests sent to the
// stream GetSourceSettings server.
func EncodeGetSourceSettingsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*stream.GetSourceSettingsPayload)
		if !ok {
			return goahttp.ErrInvalidType("stream", "GetSourceSettings", "*stream.GetSourceSettingsPayload", v)
		}
		{
			head := p.StorageAPIToken
			req.Header.Set("X-StorageApi-Token", head)
		}
		return nil
	}
}

// DecodeGetSourceSettingsResponse returns a decoder for responses returned by
// the stream GetSourceSettings endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetSourceSettingsResponse may return the following errors:
//   - "stream.sourceNotFound" (type *stream.GenericError): http.StatusNotFound
//   - error: internal error
func DecodeGetSourceSettingsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetSourceSettingsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "GetSourceSettings", err)
			}
			for _, e := range body {
				if e != nil {
					if err2 := ValidateSettingResultResponse(e); err2 != nil {
						err = goa.MergeErrors(err, err2)
					}
				}
			}
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "GetSourceSettings", err)
			}
			res := NewGetSourceSettingsSettingsResultOK(body)
			return res, nil
		case http.StatusNotFound:
			var (
				body GetSourceSettingsStreamSourceNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "GetSourceSettings", err)
			}
			err = ValidateGetSourceSettingsStreamSourceNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "GetSourceSettings", err)
			}
			return nil, NewGetSourceSettingsStreamSourceNotFound(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("stream", "GetSourceSettings", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateSourceSettingsRequest instantiates a HTTP request object with
// method and path set to call the "stream" service "UpdateSourceSettings"
// endpoint
func (c *Client) BuildUpdateSourceSettingsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		branchID string
		sourceID string
	)
	{
		p, ok := v.(*stream.UpdateSourceSettingsPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("stream", "UpdateSourceSettings", "*stream.UpdateSourceSettingsPayload", v)
		}
		branchID = string(p.BranchID)
		sourceID = string(p.SourceID)
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateSourceSettingsStreamPath(branchID, sourceID)}
	req, err := http.NewRequest("PATCH", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("stream", "UpdateSourceSettings", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateSourceSettingsRequest returns an encoder for requests sent to
// the stream UpdateSourceSettings server.
func EncodeUpdateSourceSettingsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*stream.UpdateSourceSettingsPayload)
		if !ok {
			return goahttp.ErrInvalidType("stream", "UpdateSourceSettings", "*stream.UpdateSourceSettingsPayload", v)
		}
		{
			head := p.StorageAPIToken
			req.Header.Set("X-StorageApi-Token", head)
		}
		body := NewUpdateSourceSettingsRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("stream", "UpdateSourceSettings", err)
		}
		return nil
	}
}

// DecodeUpdateSourceSettingsResponse returns a decoder for responses returned
// by the stream UpdateSourceSettings endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodeUpdateSourceSettingsResponse may return the following errors:
//   - "stream.sourceNotFound" (type *stream.GenericError): http.StatusNotFound
//   - error: internal error
func DecodeUpdateSourceSettingsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateSourceSettingsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "UpdateSourceSettings", err)
			}
			for _, e := range body {
				if e != nil {
					if err2 := ValidateSettingResultResponse(e); err2 != nil {
						err = goa.MergeErrors(err, err2)
					}
				}
			}
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "UpdateSourceSettings", err)
			}
			res := NewUpdateSourceSettingsSettingsResultOK(body)
			return res, nil
		case http.StatusNotFound:
			var (
				body UpdateSourceSettingsStreamSourceNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "UpdateSourceSettings", err)
			}
			err = ValidateUpdateSourceSettingsStreamSourceNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "UpdateSourceSettings", err)
			}
			return nil, NewUpdateSourceSettingsStreamSourceNotFound(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("stream", "UpdateSourceSettings", resp.StatusCode, string(body))
		}
	}
}

// BuildRefreshSourceTokensRequest instantiates a HTTP request object with
// method and path set to call the "stream" service "RefreshSourceTokens"
// endpoint
func (c *Client) BuildRefreshSourceTokensRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		branchID string
		sourceID string
	)
	{
		p, ok := v.(*stream.RefreshSourceTokensPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("stream", "RefreshSourceTokens", "*stream.RefreshSourceTokensPayload", v)
		}
		branchID = string(p.BranchID)
		sourceID = string(p.SourceID)
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: RefreshSourceTokensStreamPath(branchID, sourceID)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("stream", "RefreshSourceTokens", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeRefreshSourceTokensRequest returns an encoder for requests sent to the
// stream RefreshSourceTokens server.
func EncodeRefreshSourceTokensRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*stream.RefreshSourceTokensPayload)
		if !ok {
			return goahttp.ErrInvalidType("stream", "RefreshSourceTokens", "*stream.RefreshSourceTokensPayload", v)
		}
		{
			head := p.StorageAPIToken
			req.Header.Set("X-StorageApi-Token", head)
		}
		return nil
	}
}

// DecodeRefreshSourceTokensResponse returns a decoder for responses returned
// by the stream RefreshSourceTokens endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeRefreshSourceTokensResponse may return the following errors:
//   - "stream.sourceNotFound" (type *stream.GenericError): http.StatusNotFound
//   - error: internal error
func DecodeRefreshSourceTokensResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body RefreshSourceTokensResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "RefreshSourceTokens", err)
			}
			err = ValidateRefreshSourceTokensResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "RefreshSourceTokens", err)
			}
			res := NewRefreshSourceTokensSourceOK(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body RefreshSourceTokensStreamSourceNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "RefreshSourceTokens", err)
			}
			err = ValidateRefreshSourceTokensStreamSourceNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "RefreshSourceTokens", err)
			}
			return nil, NewRefreshSourceTokensStreamSourceNotFound(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("stream", "RefreshSourceTokens", resp.StatusCode, string(body))
		}
	}
}

// BuildCreateSinkRequest instantiates a HTTP request object with method and
// path set to call the "stream" service "CreateSink" endpoint
func (c *Client) BuildCreateSinkRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		branchID string
		sourceID string
	)
	{
		p, ok := v.(*stream.CreateSinkPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("stream", "CreateSink", "*stream.CreateSinkPayload", v)
		}
		branchID = string(p.BranchID)
		sourceID = string(p.SourceID)
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateSinkStreamPath(branchID, sourceID)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("stream", "CreateSink", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateSinkRequest returns an encoder for requests sent to the stream
// CreateSink server.
func EncodeCreateSinkRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*stream.CreateSinkPayload)
		if !ok {
			return goahttp.ErrInvalidType("stream", "CreateSink", "*stream.CreateSinkPayload", v)
		}
		{
			head := p.StorageAPIToken
			req.Header.Set("X-StorageApi-Token", head)
		}
		body := NewCreateSinkRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("stream", "CreateSink", err)
		}
		return nil
	}
}

// DecodeCreateSinkResponse returns a decoder for responses returned by the
// stream CreateSink endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeCreateSinkResponse may return the following errors:
//   - "stream.sourceNotFound" (type *stream.GenericError): http.StatusNotFound
//   - "stream.sinkAlreadyExists" (type *stream.GenericError): http.StatusConflict
//   - "stream.resourceLimitReached" (type *stream.GenericError): http.StatusUnprocessableEntity
//   - error: internal error
func DecodeCreateSinkResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusAccepted:
			var (
				body CreateSinkResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "CreateSink", err)
			}
			err = ValidateCreateSinkResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "CreateSink", err)
			}
			res := NewCreateSinkTaskAccepted(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body CreateSinkStreamSourceNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "CreateSink", err)
			}
			err = ValidateCreateSinkStreamSourceNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "CreateSink", err)
			}
			return nil, NewCreateSinkStreamSourceNotFound(&body)
		case http.StatusConflict:
			var (
				body CreateSinkStreamSinkAlreadyExistsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "CreateSink", err)
			}
			err = ValidateCreateSinkStreamSinkAlreadyExistsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "CreateSink", err)
			}
			return nil, NewCreateSinkStreamSinkAlreadyExists(&body)
		case http.StatusUnprocessableEntity:
			var (
				body CreateSinkStreamResourceLimitReachedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "CreateSink", err)
			}
			err = ValidateCreateSinkStreamResourceLimitReachedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "CreateSink", err)
			}
			return nil, NewCreateSinkStreamResourceLimitReached(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("stream", "CreateSink", resp.StatusCode, string(body))
		}
	}
}

// BuildGetSinkRequest instantiates a HTTP request object with method and path
// set to call the "stream" service "GetSink" endpoint
func (c *Client) BuildGetSinkRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		branchID string
		sourceID string
		sinkID   string
	)
	{
		p, ok := v.(*stream.GetSinkPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("stream", "GetSink", "*stream.GetSinkPayload", v)
		}
		branchID = string(p.BranchID)
		sourceID = string(p.SourceID)
		sinkID = string(p.SinkID)
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetSinkStreamPath(branchID, sourceID, sinkID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("stream", "GetSink", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetSinkRequest returns an encoder for requests sent to the stream
// GetSink server.
func EncodeGetSinkRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*stream.GetSinkPayload)
		if !ok {
			return goahttp.ErrInvalidType("stream", "GetSink", "*stream.GetSinkPayload", v)
		}
		{
			head := p.StorageAPIToken
			req.Header.Set("X-StorageApi-Token", head)
		}
		return nil
	}
}

// DecodeGetSinkResponse returns a decoder for responses returned by the stream
// GetSink endpoint. restoreBody controls whether the response body should be
// restored after having been read.
// DecodeGetSinkResponse may return the following errors:
//   - "stream.sourceNotFound" (type *stream.GenericError): http.StatusNotFound
//   - "stream.sinkNotFound" (type *stream.GenericError): http.StatusNotFound
//   - error: internal error
func DecodeGetSinkResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetSinkResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "GetSink", err)
			}
			err = ValidateGetSinkResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "GetSink", err)
			}
			res := NewGetSinkSinkOK(&body)
			return res, nil
		case http.StatusNotFound:
			en := resp.Header.Get("goa-error")
			switch en {
			case "stream.sourceNotFound":
				var (
					body GetSinkStreamSourceNotFoundResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("stream", "GetSink", err)
				}
				err = ValidateGetSinkStreamSourceNotFoundResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("stream", "GetSink", err)
				}
				return nil, NewGetSinkStreamSourceNotFound(&body)
			case "stream.sinkNotFound":
				var (
					body GetSinkStreamSinkNotFoundResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("stream", "GetSink", err)
				}
				err = ValidateGetSinkStreamSinkNotFoundResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("stream", "GetSink", err)
				}
				return nil, NewGetSinkStreamSinkNotFound(&body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("stream", "GetSink", resp.StatusCode, string(body))
			}
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("stream", "GetSink", resp.StatusCode, string(body))
		}
	}
}

// BuildGetSinkSettingsRequest instantiates a HTTP request object with method
// and path set to call the "stream" service "GetSinkSettings" endpoint
func (c *Client) BuildGetSinkSettingsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		branchID string
		sourceID string
		sinkID   string
	)
	{
		p, ok := v.(*stream.GetSinkSettingsPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("stream", "GetSinkSettings", "*stream.GetSinkSettingsPayload", v)
		}
		branchID = string(p.BranchID)
		sourceID = string(p.SourceID)
		sinkID = string(p.SinkID)
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetSinkSettingsStreamPath(branchID, sourceID, sinkID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("stream", "GetSinkSettings", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetSinkSettingsRequest returns an encoder for requests sent to the
// stream GetSinkSettings server.
func EncodeGetSinkSettingsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*stream.GetSinkSettingsPayload)
		if !ok {
			return goahttp.ErrInvalidType("stream", "GetSinkSettings", "*stream.GetSinkSettingsPayload", v)
		}
		{
			head := p.StorageAPIToken
			req.Header.Set("X-StorageApi-Token", head)
		}
		return nil
	}
}

// DecodeGetSinkSettingsResponse returns a decoder for responses returned by
// the stream GetSinkSettings endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetSinkSettingsResponse may return the following errors:
//   - "stream.sourceNotFound" (type *stream.GenericError): http.StatusNotFound
//   - "stream.sinkNotFound" (type *stream.GenericError): http.StatusNotFound
//   - error: internal error
func DecodeGetSinkSettingsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetSinkSettingsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "GetSinkSettings", err)
			}
			for _, e := range body {
				if e != nil {
					if err2 := ValidateSettingResultResponse(e); err2 != nil {
						err = goa.MergeErrors(err, err2)
					}
				}
			}
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "GetSinkSettings", err)
			}
			res := NewGetSinkSettingsSettingsResultOK(body)
			return res, nil
		case http.StatusNotFound:
			en := resp.Header.Get("goa-error")
			switch en {
			case "stream.sourceNotFound":
				var (
					body GetSinkSettingsStreamSourceNotFoundResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("stream", "GetSinkSettings", err)
				}
				err = ValidateGetSinkSettingsStreamSourceNotFoundResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("stream", "GetSinkSettings", err)
				}
				return nil, NewGetSinkSettingsStreamSourceNotFound(&body)
			case "stream.sinkNotFound":
				var (
					body GetSinkSettingsStreamSinkNotFoundResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("stream", "GetSinkSettings", err)
				}
				err = ValidateGetSinkSettingsStreamSinkNotFoundResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("stream", "GetSinkSettings", err)
				}
				return nil, NewGetSinkSettingsStreamSinkNotFound(&body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("stream", "GetSinkSettings", resp.StatusCode, string(body))
			}
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("stream", "GetSinkSettings", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateSinkSettingsRequest instantiates a HTTP request object with
// method and path set to call the "stream" service "UpdateSinkSettings"
// endpoint
func (c *Client) BuildUpdateSinkSettingsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		branchID string
		sourceID string
		sinkID   string
	)
	{
		p, ok := v.(*stream.UpdateSinkSettingsPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("stream", "UpdateSinkSettings", "*stream.UpdateSinkSettingsPayload", v)
		}
		branchID = string(p.BranchID)
		sourceID = string(p.SourceID)
		sinkID = string(p.SinkID)
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateSinkSettingsStreamPath(branchID, sourceID, sinkID)}
	req, err := http.NewRequest("PATCH", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("stream", "UpdateSinkSettings", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateSinkSettingsRequest returns an encoder for requests sent to the
// stream UpdateSinkSettings server.
func EncodeUpdateSinkSettingsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*stream.UpdateSinkSettingsPayload)
		if !ok {
			return goahttp.ErrInvalidType("stream", "UpdateSinkSettings", "*stream.UpdateSinkSettingsPayload", v)
		}
		{
			head := p.StorageAPIToken
			req.Header.Set("X-StorageApi-Token", head)
		}
		body := NewUpdateSinkSettingsRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("stream", "UpdateSinkSettings", err)
		}
		return nil
	}
}

// DecodeUpdateSinkSettingsResponse returns a decoder for responses returned by
// the stream UpdateSinkSettings endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeUpdateSinkSettingsResponse may return the following errors:
//   - "stream.sourceNotFound" (type *stream.GenericError): http.StatusNotFound
//   - "stream.sinkNotFound" (type *stream.GenericError): http.StatusNotFound
//   - error: internal error
func DecodeUpdateSinkSettingsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateSinkSettingsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "UpdateSinkSettings", err)
			}
			for _, e := range body {
				if e != nil {
					if err2 := ValidateSettingResultResponse(e); err2 != nil {
						err = goa.MergeErrors(err, err2)
					}
				}
			}
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "UpdateSinkSettings", err)
			}
			res := NewUpdateSinkSettingsSettingsResultOK(body)
			return res, nil
		case http.StatusNotFound:
			en := resp.Header.Get("goa-error")
			switch en {
			case "stream.sourceNotFound":
				var (
					body UpdateSinkSettingsStreamSourceNotFoundResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("stream", "UpdateSinkSettings", err)
				}
				err = ValidateUpdateSinkSettingsStreamSourceNotFoundResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("stream", "UpdateSinkSettings", err)
				}
				return nil, NewUpdateSinkSettingsStreamSourceNotFound(&body)
			case "stream.sinkNotFound":
				var (
					body UpdateSinkSettingsStreamSinkNotFoundResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("stream", "UpdateSinkSettings", err)
				}
				err = ValidateUpdateSinkSettingsStreamSinkNotFoundResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("stream", "UpdateSinkSettings", err)
				}
				return nil, NewUpdateSinkSettingsStreamSinkNotFound(&body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("stream", "UpdateSinkSettings", resp.StatusCode, string(body))
			}
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("stream", "UpdateSinkSettings", resp.StatusCode, string(body))
		}
	}
}

// BuildListSinksRequest instantiates a HTTP request object with method and
// path set to call the "stream" service "ListSinks" endpoint
func (c *Client) BuildListSinksRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		branchID string
		sourceID string
	)
	{
		p, ok := v.(*stream.ListSinksPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("stream", "ListSinks", "*stream.ListSinksPayload", v)
		}
		branchID = string(p.BranchID)
		sourceID = string(p.SourceID)
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListSinksStreamPath(branchID, sourceID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("stream", "ListSinks", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListSinksRequest returns an encoder for requests sent to the stream
// ListSinks server.
func EncodeListSinksRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*stream.ListSinksPayload)
		if !ok {
			return goahttp.ErrInvalidType("stream", "ListSinks", "*stream.ListSinksPayload", v)
		}
		{
			head := p.StorageAPIToken
			req.Header.Set("X-StorageApi-Token", head)
		}
		return nil
	}
}

// DecodeListSinksResponse returns a decoder for responses returned by the
// stream ListSinks endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeListSinksResponse may return the following errors:
//   - "stream.sourceNotFound" (type *stream.GenericError): http.StatusNotFound
//   - error: internal error
func DecodeListSinksResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListSinksResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "ListSinks", err)
			}
			err = ValidateListSinksResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "ListSinks", err)
			}
			res := NewListSinksSinksListOK(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body ListSinksStreamSourceNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "ListSinks", err)
			}
			err = ValidateListSinksStreamSourceNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "ListSinks", err)
			}
			return nil, NewListSinksStreamSourceNotFound(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("stream", "ListSinks", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateSinkRequest instantiates a HTTP request object with method and
// path set to call the "stream" service "UpdateSink" endpoint
func (c *Client) BuildUpdateSinkRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		branchID string
		sourceID string
		sinkID   string
	)
	{
		p, ok := v.(*stream.UpdateSinkPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("stream", "UpdateSink", "*stream.UpdateSinkPayload", v)
		}
		branchID = string(p.BranchID)
		sourceID = string(p.SourceID)
		sinkID = string(p.SinkID)
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateSinkStreamPath(branchID, sourceID, sinkID)}
	req, err := http.NewRequest("PATCH", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("stream", "UpdateSink", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateSinkRequest returns an encoder for requests sent to the stream
// UpdateSink server.
func EncodeUpdateSinkRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*stream.UpdateSinkPayload)
		if !ok {
			return goahttp.ErrInvalidType("stream", "UpdateSink", "*stream.UpdateSinkPayload", v)
		}
		{
			head := p.StorageAPIToken
			req.Header.Set("X-StorageApi-Token", head)
		}
		body := NewUpdateSinkRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("stream", "UpdateSink", err)
		}
		return nil
	}
}

// DecodeUpdateSinkResponse returns a decoder for responses returned by the
// stream UpdateSink endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeUpdateSinkResponse may return the following errors:
//   - "stream.sourceNotFound" (type *stream.GenericError): http.StatusNotFound
//   - "stream.sinkNotFound" (type *stream.GenericError): http.StatusNotFound
//   - error: internal error
func DecodeUpdateSinkResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateSinkResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "UpdateSink", err)
			}
			err = ValidateUpdateSinkResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "UpdateSink", err)
			}
			res := NewUpdateSinkTaskOK(&body)
			return res, nil
		case http.StatusNotFound:
			en := resp.Header.Get("goa-error")
			switch en {
			case "stream.sourceNotFound":
				var (
					body UpdateSinkStreamSourceNotFoundResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("stream", "UpdateSink", err)
				}
				err = ValidateUpdateSinkStreamSourceNotFoundResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("stream", "UpdateSink", err)
				}
				return nil, NewUpdateSinkStreamSourceNotFound(&body)
			case "stream.sinkNotFound":
				var (
					body UpdateSinkStreamSinkNotFoundResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("stream", "UpdateSink", err)
				}
				err = ValidateUpdateSinkStreamSinkNotFoundResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("stream", "UpdateSink", err)
				}
				return nil, NewUpdateSinkStreamSinkNotFound(&body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("stream", "UpdateSink", resp.StatusCode, string(body))
			}
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("stream", "UpdateSink", resp.StatusCode, string(body))
		}
	}
}

// BuildDeleteSinkRequest instantiates a HTTP request object with method and
// path set to call the "stream" service "DeleteSink" endpoint
func (c *Client) BuildDeleteSinkRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		branchID string
		sourceID string
		sinkID   string
	)
	{
		p, ok := v.(*stream.DeleteSinkPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("stream", "DeleteSink", "*stream.DeleteSinkPayload", v)
		}
		branchID = string(p.BranchID)
		sourceID = string(p.SourceID)
		sinkID = string(p.SinkID)
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeleteSinkStreamPath(branchID, sourceID, sinkID)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("stream", "DeleteSink", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeleteSinkRequest returns an encoder for requests sent to the stream
// DeleteSink server.
func EncodeDeleteSinkRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*stream.DeleteSinkPayload)
		if !ok {
			return goahttp.ErrInvalidType("stream", "DeleteSink", "*stream.DeleteSinkPayload", v)
		}
		{
			head := p.StorageAPIToken
			req.Header.Set("X-StorageApi-Token", head)
		}
		return nil
	}
}

// DecodeDeleteSinkResponse returns a decoder for responses returned by the
// stream DeleteSink endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeDeleteSinkResponse may return the following errors:
//   - "stream.sourceNotFound" (type *stream.GenericError): http.StatusNotFound
//   - "stream.sinkNotFound" (type *stream.GenericError): http.StatusNotFound
//   - error: internal error
func DecodeDeleteSinkResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			return nil, nil
		case http.StatusNotFound:
			en := resp.Header.Get("goa-error")
			switch en {
			case "stream.sourceNotFound":
				var (
					body DeleteSinkStreamSourceNotFoundResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("stream", "DeleteSink", err)
				}
				err = ValidateDeleteSinkStreamSourceNotFoundResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("stream", "DeleteSink", err)
				}
				return nil, NewDeleteSinkStreamSourceNotFound(&body)
			case "stream.sinkNotFound":
				var (
					body DeleteSinkStreamSinkNotFoundResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("stream", "DeleteSink", err)
				}
				err = ValidateDeleteSinkStreamSinkNotFoundResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("stream", "DeleteSink", err)
				}
				return nil, NewDeleteSinkStreamSinkNotFound(&body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("stream", "DeleteSink", resp.StatusCode, string(body))
			}
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("stream", "DeleteSink", resp.StatusCode, string(body))
		}
	}
}

// BuildGetTaskRequest instantiates a HTTP request object with method and path
// set to call the "stream" service "GetTask" endpoint
func (c *Client) BuildGetTaskRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		branchID int
		taskID   string
	)
	{
		p, ok := v.(*stream.GetTaskPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("stream", "GetTask", "*stream.GetTaskPayload", v)
		}
		if p.BranchID != nil {
			branchID = int(*p.BranchID)
		}
		taskID = string(p.TaskID)
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetTaskStreamPath(branchID, taskID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("stream", "GetTask", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetTaskRequest returns an encoder for requests sent to the stream
// GetTask server.
func EncodeGetTaskRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*stream.GetTaskPayload)
		if !ok {
			return goahttp.ErrInvalidType("stream", "GetTask", "*stream.GetTaskPayload", v)
		}
		{
			head := p.StorageAPIToken
			req.Header.Set("X-StorageApi-Token", head)
		}
		return nil
	}
}

// DecodeGetTaskResponse returns a decoder for responses returned by the stream
// GetTask endpoint. restoreBody controls whether the response body should be
// restored after having been read.
// DecodeGetTaskResponse may return the following errors:
//   - "stream.taskNotFound" (type *stream.GenericError): http.StatusNotFound
//   - error: internal error
func DecodeGetTaskResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetTaskResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "GetTask", err)
			}
			err = ValidateGetTaskResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "GetTask", err)
			}
			res := NewGetTaskTaskOK(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body GetTaskStreamTaskNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("stream", "GetTask", err)
			}
			err = ValidateGetTaskStreamTaskNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("stream", "GetTask", err)
			}
			return nil, NewGetTaskStreamTaskNotFound(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("stream", "GetTask", resp.StatusCode, string(body))
		}
	}
}

// unmarshalTaskOutputsResponseBodyToStreamTaskOutputs builds a value of type
// *stream.TaskOutputs from a value of type *TaskOutputsResponseBody.
func unmarshalTaskOutputsResponseBodyToStreamTaskOutputs(v *TaskOutputsResponseBody) *stream.TaskOutputs {
	if v == nil {
		return nil
	}
	res := &stream.TaskOutputs{}
	if v.SinkID != nil {
		sinkID := stream.SinkID(*v.SinkID)
		res.SinkID = &sinkID
	}
	if v.SourceID != nil {
		sourceID := stream.SourceID(*v.SourceID)
		res.SourceID = &sourceID
	}

	return res
}

// unmarshalHTTPSourceResponseBodyToStreamHTTPSource builds a value of type
// *stream.HTTPSource from a value of type *HTTPSourceResponseBody.
func unmarshalHTTPSourceResponseBodyToStreamHTTPSource(v *HTTPSourceResponseBody) *stream.HTTPSource {
	if v == nil {
		return nil
	}
	res := &stream.HTTPSource{
		URL: *v.URL,
	}

	return res
}

// unmarshalVersionResponseBodyToStreamVersion builds a value of type
// *stream.Version from a value of type *VersionResponseBody.
func unmarshalVersionResponseBodyToStreamVersion(v *VersionResponseBody) *stream.Version {
	res := &stream.Version{
		Number:      *v.Number,
		Hash:        *v.Hash,
		ModifiedAt:  *v.ModifiedAt,
		Description: *v.Description,
	}

	return res
}

// unmarshalDeletedEntityResponseBodyToStreamDeletedEntity builds a value of
// type *stream.DeletedEntity from a value of type *DeletedEntityResponseBody.
func unmarshalDeletedEntityResponseBodyToStreamDeletedEntity(v *DeletedEntityResponseBody) *stream.DeletedEntity {
	if v == nil {
		return nil
	}
	res := &stream.DeletedEntity{
		At: *v.At,
	}
	res.By = unmarshalByResponseBodyToStreamBy(v.By)

	return res
}

// unmarshalByResponseBodyToStreamBy builds a value of type *stream.By from a
// value of type *ByResponseBody.
func unmarshalByResponseBodyToStreamBy(v *ByResponseBody) *stream.By {
	res := &stream.By{
		Type:            *v.Type,
		TokenID:         v.TokenID,
		UserID:          v.UserID,
		UserDescription: v.UserDescription,
	}

	return res
}

// unmarshalDisabledEntityResponseBodyToStreamDisabledEntity builds a value of
// type *stream.DisabledEntity from a value of type *DisabledEntityResponseBody.
func unmarshalDisabledEntityResponseBodyToStreamDisabledEntity(v *DisabledEntityResponseBody) *stream.DisabledEntity {
	if v == nil {
		return nil
	}
	res := &stream.DisabledEntity{
		At:     *v.At,
		Reason: *v.Reason,
	}
	res.By = unmarshalByResponseBodyToStreamBy(v.By)

	return res
}

// unmarshalSinkResponseBodyToStreamSink builds a value of type *stream.Sink
// from a value of type *SinkResponseBody.
func unmarshalSinkResponseBodyToStreamSink(v *SinkResponseBody) *stream.Sink {
	res := &stream.Sink{
		ProjectID:   stream.ProjectID(*v.ProjectID),
		BranchID:    stream.BranchID(*v.BranchID),
		SourceID:    stream.SourceID(*v.SourceID),
		SinkID:      stream.SinkID(*v.SinkID),
		Name:        *v.Name,
		Description: *v.Description,
	}
	if v.Type != nil {
		type_ := stream.SinkType(*v.Type)
		res.Type = &type_
	}
	if v.Table != nil {
		res.Table = unmarshalTableSinkResponseBodyToStreamTableSink(v.Table)
	}
	res.Version = unmarshalVersionResponseBodyToStreamVersion(v.Version)
	if v.Deleted != nil {
		res.Deleted = unmarshalDeletedEntityResponseBodyToStreamDeletedEntity(v.Deleted)
	}
	if v.Disabled != nil {
		res.Disabled = unmarshalDisabledEntityResponseBodyToStreamDisabledEntity(v.Disabled)
	}

	return res
}

// unmarshalTableSinkResponseBodyToStreamTableSink builds a value of type
// *stream.TableSink from a value of type *TableSinkResponseBody.
func unmarshalTableSinkResponseBodyToStreamTableSink(v *TableSinkResponseBody) *stream.TableSink {
	if v == nil {
		return nil
	}
	res := &stream.TableSink{}
	if v.Mapping != nil {
		res.Mapping = unmarshalTableMappingResponseBodyToStreamTableMapping(v.Mapping)
	}

	return res
}

// unmarshalTableMappingResponseBodyToStreamTableMapping builds a value of type
// *stream.TableMapping from a value of type *TableMappingResponseBody.
func unmarshalTableMappingResponseBodyToStreamTableMapping(v *TableMappingResponseBody) *stream.TableMapping {
	if v == nil {
		return nil
	}
	res := &stream.TableMapping{
		TableID: stream.TableID(*v.TableID),
	}
	res.Columns = make([]*stream.TableColumn, len(v.Columns))
	for i, val := range v.Columns {
		res.Columns[i] = unmarshalTableColumnResponseBodyToStreamTableColumn(val)
	}

	return res
}

// unmarshalTableColumnResponseBodyToStreamTableColumn builds a value of type
// *stream.TableColumn from a value of type *TableColumnResponseBody.
func unmarshalTableColumnResponseBodyToStreamTableColumn(v *TableColumnResponseBody) *stream.TableColumn {
	res := &stream.TableColumn{
		Type: *v.Type,
		Name: *v.Name,
	}
	if v.PrimaryKey != nil {
		res.PrimaryKey = *v.PrimaryKey
	}
	if v.PrimaryKey == nil {
		res.PrimaryKey = false
	}
	if v.Template != nil {
		res.Template = unmarshalTableColumnTemplateResponseBodyToStreamTableColumnTemplate(v.Template)
	}

	return res
}

// unmarshalTableColumnTemplateResponseBodyToStreamTableColumnTemplate builds a
// value of type *stream.TableColumnTemplate from a value of type
// *TableColumnTemplateResponseBody.
func unmarshalTableColumnTemplateResponseBodyToStreamTableColumnTemplate(v *TableColumnTemplateResponseBody) *stream.TableColumnTemplate {
	if v == nil {
		return nil
	}
	res := &stream.TableColumnTemplate{
		Language: *v.Language,
		Content:  *v.Content,
	}

	return res
}

// unmarshalSourceResponseBodyToStreamSource builds a value of type
// *stream.Source from a value of type *SourceResponseBody.
func unmarshalSourceResponseBodyToStreamSource(v *SourceResponseBody) *stream.Source {
	res := &stream.Source{
		ProjectID:   stream.ProjectID(*v.ProjectID),
		BranchID:    stream.BranchID(*v.BranchID),
		SourceID:    stream.SourceID(*v.SourceID),
		Type:        stream.SourceType(*v.Type),
		Name:        *v.Name,
		Description: *v.Description,
	}
	if v.HTTP != nil {
		res.HTTP = unmarshalHTTPSourceResponseBodyToStreamHTTPSource(v.HTTP)
	}
	res.Version = unmarshalVersionResponseBodyToStreamVersion(v.Version)
	if v.Deleted != nil {
		res.Deleted = unmarshalDeletedEntityResponseBodyToStreamDeletedEntity(v.Deleted)
	}
	if v.Disabled != nil {
		res.Disabled = unmarshalDisabledEntityResponseBodyToStreamDisabledEntity(v.Disabled)
	}
	res.Sinks = make([]*stream.Sink, len(v.Sinks))
	for i, val := range v.Sinks {
		res.Sinks[i] = unmarshalSinkResponseBodyToStreamSink(val)
	}

	return res
}

// unmarshalSettingResultResponseToStreamSettingResult builds a value of type
// *stream.SettingResult from a value of type *SettingResultResponse.
func unmarshalSettingResultResponseToStreamSettingResult(v *SettingResultResponse) *stream.SettingResult {
	res := &stream.SettingResult{
		Key:          *v.Key,
		Type:         *v.Type,
		Value:        v.Value,
		DefaultValue: v.DefaultValue,
		Overwritten:  *v.Overwritten,
		Protected:    *v.Protected,
		Validation:   v.Validation,
	}

	return res
}

// marshalStreamSettingPatchToSettingPatchRequestBody builds a value of type
// *SettingPatchRequestBody from a value of type *stream.SettingPatch.
func marshalStreamSettingPatchToSettingPatchRequestBody(v *stream.SettingPatch) *SettingPatchRequestBody {
	if v == nil {
		return nil
	}
	res := &SettingPatchRequestBody{
		Key:   v.Key,
		Value: v.Value,
	}

	return res
}

// marshalSettingPatchRequestBodyToStreamSettingPatch builds a value of type
// *stream.SettingPatch from a value of type *SettingPatchRequestBody.
func marshalSettingPatchRequestBodyToStreamSettingPatch(v *SettingPatchRequestBody) *stream.SettingPatch {
	if v == nil {
		return nil
	}
	res := &stream.SettingPatch{
		Key:   v.Key,
		Value: v.Value,
	}

	return res
}

// marshalStreamTableSinkToTableSinkRequestBody builds a value of type
// *TableSinkRequestBody from a value of type *stream.TableSink.
func marshalStreamTableSinkToTableSinkRequestBody(v *stream.TableSink) *TableSinkRequestBody {
	if v == nil {
		return nil
	}
	res := &TableSinkRequestBody{}
	if v.Mapping != nil {
		res.Mapping = marshalStreamTableMappingToTableMappingRequestBody(v.Mapping)
	}

	return res
}

// marshalStreamTableMappingToTableMappingRequestBody builds a value of type
// *TableMappingRequestBody from a value of type *stream.TableMapping.
func marshalStreamTableMappingToTableMappingRequestBody(v *stream.TableMapping) *TableMappingRequestBody {
	if v == nil {
		return nil
	}
	res := &TableMappingRequestBody{
		TableID: string(v.TableID),
	}
	if v.Columns != nil {
		res.Columns = make([]*TableColumnRequestBody, len(v.Columns))
		for i, val := range v.Columns {
			res.Columns[i] = marshalStreamTableColumnToTableColumnRequestBody(val)
		}
	} else {
		res.Columns = []*TableColumnRequestBody{}
	}

	return res
}

// marshalStreamTableColumnToTableColumnRequestBody builds a value of type
// *TableColumnRequestBody from a value of type *stream.TableColumn.
func marshalStreamTableColumnToTableColumnRequestBody(v *stream.TableColumn) *TableColumnRequestBody {
	res := &TableColumnRequestBody{
		PrimaryKey: v.PrimaryKey,
		Type:       v.Type,
		Name:       v.Name,
	}
	{
		var zero bool
		if res.PrimaryKey == zero {
			res.PrimaryKey = false
		}
	}
	if v.Template != nil {
		res.Template = marshalStreamTableColumnTemplateToTableColumnTemplateRequestBody(v.Template)
	}

	return res
}

// marshalStreamTableColumnTemplateToTableColumnTemplateRequestBody builds a
// value of type *TableColumnTemplateRequestBody from a value of type
// *stream.TableColumnTemplate.
func marshalStreamTableColumnTemplateToTableColumnTemplateRequestBody(v *stream.TableColumnTemplate) *TableColumnTemplateRequestBody {
	if v == nil {
		return nil
	}
	res := &TableColumnTemplateRequestBody{
		Language: v.Language,
		Content:  v.Content,
	}

	return res
}

// marshalTableSinkRequestBodyToStreamTableSink builds a value of type
// *stream.TableSink from a value of type *TableSinkRequestBody.
func marshalTableSinkRequestBodyToStreamTableSink(v *TableSinkRequestBody) *stream.TableSink {
	if v == nil {
		return nil
	}
	res := &stream.TableSink{}
	if v.Mapping != nil {
		res.Mapping = marshalTableMappingRequestBodyToStreamTableMapping(v.Mapping)
	}

	return res
}

// marshalTableMappingRequestBodyToStreamTableMapping builds a value of type
// *stream.TableMapping from a value of type *TableMappingRequestBody.
func marshalTableMappingRequestBodyToStreamTableMapping(v *TableMappingRequestBody) *stream.TableMapping {
	if v == nil {
		return nil
	}
	res := &stream.TableMapping{
		TableID: stream.TableID(v.TableID),
	}
	if v.Columns != nil {
		res.Columns = make([]*stream.TableColumn, len(v.Columns))
		for i, val := range v.Columns {
			res.Columns[i] = marshalTableColumnRequestBodyToStreamTableColumn(val)
		}
	} else {
		res.Columns = []*stream.TableColumn{}
	}

	return res
}

// marshalTableColumnRequestBodyToStreamTableColumn builds a value of type
// *stream.TableColumn from a value of type *TableColumnRequestBody.
func marshalTableColumnRequestBodyToStreamTableColumn(v *TableColumnRequestBody) *stream.TableColumn {
	res := &stream.TableColumn{
		PrimaryKey: v.PrimaryKey,
		Type:       v.Type,
		Name:       v.Name,
	}
	{
		var zero bool
		if res.PrimaryKey == zero {
			res.PrimaryKey = false
		}
	}
	if v.Template != nil {
		res.Template = marshalTableColumnTemplateRequestBodyToStreamTableColumnTemplate(v.Template)
	}

	return res
}

// marshalTableColumnTemplateRequestBodyToStreamTableColumnTemplate builds a
// value of type *stream.TableColumnTemplate from a value of type
// *TableColumnTemplateRequestBody.
func marshalTableColumnTemplateRequestBodyToStreamTableColumnTemplate(v *TableColumnTemplateRequestBody) *stream.TableColumnTemplate {
	if v == nil {
		return nil
	}
	res := &stream.TableColumnTemplate{
		Language: v.Language,
		Content:  v.Content,
	}

	return res
}
