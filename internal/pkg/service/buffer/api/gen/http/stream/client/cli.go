// Code generated by goa v3.14.6, DO NOT EDIT.
//
// stream HTTP client CLI support package
//
// Command:
// $ goa gen github.com/keboola/keboola-as-code/api/buffer --output
// ./internal/pkg/service/buffer/api

package client

import (
	"encoding/json"
	"fmt"
	"strconv"
	"unicode/utf8"

	stream "github.com/keboola/keboola-as-code/internal/pkg/service/buffer/api/gen/stream"
	goa "goa.design/goa/v3/pkg"
)

// BuildCreateSourcePayload builds the payload for the stream CreateSource
// endpoint from CLI flags.
func BuildCreateSourcePayload(streamCreateSourceBody string, streamCreateSourceBranchID string, streamCreateSourceStorageAPIToken string) (*stream.CreateSourcePayload, error) {
	var err error
	var body CreateSourceRequestBody
	{
		err = json.Unmarshal([]byte(streamCreateSourceBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"sourceId\": \"github-webhook-source\",\n      \"type\": \"http\",\n      \"name\": \"Github Webhook Source\",\n      \"description\": \"The source receives events from Github.\"\n   }'")
		}
		if body.SourceID != nil {
			if utf8.RuneCountInString(*body.SourceID) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.sourceId", *body.SourceID, utf8.RuneCountInString(*body.SourceID), 1, true))
			}
		}
		if body.SourceID != nil {
			if utf8.RuneCountInString(*body.SourceID) > 48 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.sourceId", *body.SourceID, utf8.RuneCountInString(*body.SourceID), 48, false))
			}
		}
		if !(body.Type == "http") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", body.Type, []any{"http"}))
		}
		if utf8.RuneCountInString(body.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", body.Name, utf8.RuneCountInString(body.Name), 1, true))
		}
		if utf8.RuneCountInString(body.Name) > 40 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", body.Name, utf8.RuneCountInString(body.Name), 40, false))
		}
		if body.Description != nil {
			if utf8.RuneCountInString(*body.Description) > 4096 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 4096, false))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var branchID string
	{
		branchID = streamCreateSourceBranchID
	}
	var storageAPIToken string
	{
		storageAPIToken = streamCreateSourceStorageAPIToken
	}
	v := &stream.CreateSourcePayload{
		Type:        stream.SourceType(body.Type),
		Name:        body.Name,
		Description: body.Description,
	}
	if body.SourceID != nil {
		sourceID := stream.SourceID(*body.SourceID)
		v.SourceID = &sourceID
	}
	v.BranchID = stream.BranchIDOrDefault(branchID)
	v.StorageAPIToken = storageAPIToken

	return v, nil
}

// BuildUpdateSourcePayload builds the payload for the stream UpdateSource
// endpoint from CLI flags.
func BuildUpdateSourcePayload(streamUpdateSourceBody string, streamUpdateSourceBranchID string, streamUpdateSourceSourceID string, streamUpdateSourceStorageAPIToken string) (*stream.UpdateSourcePayload, error) {
	var err error
	var body UpdateSourceRequestBody
	{
		err = json.Unmarshal([]byte(streamUpdateSourceBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"type\": \"http\",\n      \"name\": \"Github Webhook Source\",\n      \"description\": \"The source receives events from Github.\"\n   }'")
		}
		if body.Type != nil {
			if !(*body.Type == "http") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"http"}))
			}
		}
		if body.Name != nil {
			if utf8.RuneCountInString(*body.Name) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", *body.Name, utf8.RuneCountInString(*body.Name), 1, true))
			}
		}
		if body.Name != nil {
			if utf8.RuneCountInString(*body.Name) > 40 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", *body.Name, utf8.RuneCountInString(*body.Name), 40, false))
			}
		}
		if body.Description != nil {
			if utf8.RuneCountInString(*body.Description) > 4096 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 4096, false))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var branchID string
	{
		branchID = streamUpdateSourceBranchID
	}
	var sourceID string
	{
		sourceID = streamUpdateSourceSourceID
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var storageAPIToken string
	{
		storageAPIToken = streamUpdateSourceStorageAPIToken
	}
	v := &stream.UpdateSourcePayload{
		Name:        body.Name,
		Description: body.Description,
	}
	if body.Type != nil {
		type_ := stream.SourceType(*body.Type)
		v.Type = &type_
	}
	v.BranchID = stream.BranchIDOrDefault(branchID)
	v.SourceID = stream.SourceID(sourceID)
	v.StorageAPIToken = storageAPIToken

	return v, nil
}

// BuildListSourcesPayload builds the payload for the stream ListSources
// endpoint from CLI flags.
func BuildListSourcesPayload(streamListSourcesBranchID string, streamListSourcesStorageAPIToken string) (*stream.ListSourcesPayload, error) {
	var branchID string
	{
		branchID = streamListSourcesBranchID
	}
	var storageAPIToken string
	{
		storageAPIToken = streamListSourcesStorageAPIToken
	}
	v := &stream.ListSourcesPayload{}
	v.BranchID = stream.BranchIDOrDefault(branchID)
	v.StorageAPIToken = storageAPIToken

	return v, nil
}

// BuildGetSourcePayload builds the payload for the stream GetSource endpoint
// from CLI flags.
func BuildGetSourcePayload(streamGetSourceBranchID string, streamGetSourceSourceID string, streamGetSourceStorageAPIToken string) (*stream.GetSourcePayload, error) {
	var err error
	var branchID string
	{
		branchID = streamGetSourceBranchID
	}
	var sourceID string
	{
		sourceID = streamGetSourceSourceID
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var storageAPIToken string
	{
		storageAPIToken = streamGetSourceStorageAPIToken
	}
	v := &stream.GetSourcePayload{}
	v.BranchID = stream.BranchIDOrDefault(branchID)
	v.SourceID = stream.SourceID(sourceID)
	v.StorageAPIToken = storageAPIToken

	return v, nil
}

// BuildDeleteSourcePayload builds the payload for the stream DeleteSource
// endpoint from CLI flags.
func BuildDeleteSourcePayload(streamDeleteSourceBranchID string, streamDeleteSourceSourceID string, streamDeleteSourceStorageAPIToken string) (*stream.DeleteSourcePayload, error) {
	var err error
	var branchID string
	{
		branchID = streamDeleteSourceBranchID
	}
	var sourceID string
	{
		sourceID = streamDeleteSourceSourceID
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var storageAPIToken string
	{
		storageAPIToken = streamDeleteSourceStorageAPIToken
	}
	v := &stream.DeleteSourcePayload{}
	v.BranchID = stream.BranchIDOrDefault(branchID)
	v.SourceID = stream.SourceID(sourceID)
	v.StorageAPIToken = storageAPIToken

	return v, nil
}

// BuildGetSourceSettingsPayload builds the payload for the stream
// GetSourceSettings endpoint from CLI flags.
func BuildGetSourceSettingsPayload(streamGetSourceSettingsBranchID string, streamGetSourceSettingsSourceID string, streamGetSourceSettingsStorageAPIToken string) (*stream.GetSourceSettingsPayload, error) {
	var err error
	var branchID string
	{
		branchID = streamGetSourceSettingsBranchID
	}
	var sourceID string
	{
		sourceID = streamGetSourceSettingsSourceID
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var storageAPIToken string
	{
		storageAPIToken = streamGetSourceSettingsStorageAPIToken
	}
	v := &stream.GetSourceSettingsPayload{}
	v.BranchID = stream.BranchIDOrDefault(branchID)
	v.SourceID = stream.SourceID(sourceID)
	v.StorageAPIToken = storageAPIToken

	return v, nil
}

// BuildUpdateSourceSettingsPayload builds the payload for the stream
// UpdateSourceSettings endpoint from CLI flags.
func BuildUpdateSourceSettingsPayload(streamUpdateSourceSettingsBody string, streamUpdateSourceSettingsBranchID string, streamUpdateSourceSettingsSourceID string, streamUpdateSourceSettingsStorageAPIToken string) (*stream.UpdateSourceSettingsPayload, error) {
	var err error
	var body UpdateSourceSettingsRequestBody
	{
		err = json.Unmarshal([]byte(streamUpdateSourceSettingsBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"patch\": [\n         {\n            \"key\": \"some.service.limit\",\n            \"value\": \"1m20s\"\n         }\n      ]\n   }'")
		}
		for _, e := range body.Patch {
			if e != nil {
				if err2 := ValidateSettingPatchRequestBody(e); err2 != nil {
					err = goa.MergeErrors(err, err2)
				}
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var branchID string
	{
		branchID = streamUpdateSourceSettingsBranchID
	}
	var sourceID string
	{
		sourceID = streamUpdateSourceSettingsSourceID
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var storageAPIToken string
	{
		storageAPIToken = streamUpdateSourceSettingsStorageAPIToken
	}
	v := &stream.UpdateSourceSettingsPayload{}
	if body.Patch != nil {
		v.Patch = make([]*stream.SettingPatch, len(body.Patch))
		for i, val := range body.Patch {
			v.Patch[i] = marshalSettingPatchRequestBodyToStreamSettingPatch(val)
		}
	}
	v.BranchID = stream.BranchIDOrDefault(branchID)
	v.SourceID = stream.SourceID(sourceID)
	v.StorageAPIToken = storageAPIToken

	return v, nil
}

// BuildRefreshSourceTokensPayload builds the payload for the stream
// RefreshSourceTokens endpoint from CLI flags.
func BuildRefreshSourceTokensPayload(streamRefreshSourceTokensBranchID string, streamRefreshSourceTokensSourceID string, streamRefreshSourceTokensStorageAPIToken string) (*stream.RefreshSourceTokensPayload, error) {
	var err error
	var branchID string
	{
		branchID = streamRefreshSourceTokensBranchID
	}
	var sourceID string
	{
		sourceID = streamRefreshSourceTokensSourceID
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var storageAPIToken string
	{
		storageAPIToken = streamRefreshSourceTokensStorageAPIToken
	}
	v := &stream.RefreshSourceTokensPayload{}
	v.BranchID = stream.BranchIDOrDefault(branchID)
	v.SourceID = stream.SourceID(sourceID)
	v.StorageAPIToken = storageAPIToken

	return v, nil
}

// BuildCreateSinkPayload builds the payload for the stream CreateSink endpoint
// from CLI flags.
func BuildCreateSinkPayload(streamCreateSinkBody string, streamCreateSinkBranchID string, streamCreateSinkSourceID string, streamCreateSinkStorageAPIToken string) (*stream.CreateSinkPayload, error) {
	var err error
	var body CreateSinkRequestBody
	{
		err = json.Unmarshal([]byte(streamCreateSinkBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"sinkId\": \"github-pr-table-sink\",\n      \"type\": \"table\",\n      \"name\": \"Raw Data Sink\",\n      \"description\": \"The sink stores records to a table.\",\n      \"table\": {\n         \"mapping\": {\n            \"tableId\": \"in.c-bucket.table\",\n            \"columns\": [\n               {\n                  \"type\": \"id\",\n                  \"name\": \"id-col\",\n                  \"primaryKey\": true\n               },\n               {\n                  \"type\": \"datetime\",\n                  \"name\": \"datetime-col\"\n               },\n               {\n                  \"type\": \"ip\",\n                  \"name\": \"ip-col\"\n               },\n               {\n                  \"type\": \"headers\",\n                  \"name\": \"headers-col\"\n               },\n               {\n                  \"type\": \"body\",\n                  \"name\": \"body-col\"\n               },\n               {\n                  \"type\": \"template\",\n                  \"name\": \"template-col\",\n                  \"language\": \"jsonnet\",\n                  \"content\": \"body.foo + \\\"-\\\" + body.bar\"\n               }\n            ]\n         }\n      }\n   }'")
		}
		if body.SinkID != nil {
			if utf8.RuneCountInString(*body.SinkID) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.sinkId", *body.SinkID, utf8.RuneCountInString(*body.SinkID), 1, true))
			}
		}
		if body.SinkID != nil {
			if utf8.RuneCountInString(*body.SinkID) > 48 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.sinkId", *body.SinkID, utf8.RuneCountInString(*body.SinkID), 48, false))
			}
		}
		if body.Type != nil {
			if !(*body.Type == "table") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"table"}))
			}
		}
		if utf8.RuneCountInString(body.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", body.Name, utf8.RuneCountInString(body.Name), 1, true))
		}
		if utf8.RuneCountInString(body.Name) > 40 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", body.Name, utf8.RuneCountInString(body.Name), 40, false))
		}
		if body.Description != nil {
			if utf8.RuneCountInString(*body.Description) > 4096 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 4096, false))
			}
		}
		if body.Table != nil {
			if err2 := ValidateTableSinkRequestBody(body.Table); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var branchID string
	{
		branchID = streamCreateSinkBranchID
	}
	var sourceID string
	{
		sourceID = streamCreateSinkSourceID
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var storageAPIToken string
	{
		storageAPIToken = streamCreateSinkStorageAPIToken
	}
	v := &stream.CreateSinkPayload{
		Name:        body.Name,
		Description: body.Description,
	}
	if body.SinkID != nil {
		sinkID := stream.SinkID(*body.SinkID)
		v.SinkID = &sinkID
	}
	if body.Type != nil {
		type_ := stream.SinkType(*body.Type)
		v.Type = &type_
	}
	if body.Table != nil {
		v.Table = marshalTableSinkRequestBodyToStreamTableSink(body.Table)
	}
	v.BranchID = stream.BranchIDOrDefault(branchID)
	v.SourceID = stream.SourceID(sourceID)
	v.StorageAPIToken = storageAPIToken

	return v, nil
}

// BuildGetSinkPayload builds the payload for the stream GetSink endpoint from
// CLI flags.
func BuildGetSinkPayload(streamGetSinkBranchID string, streamGetSinkSourceID string, streamGetSinkSinkID string, streamGetSinkStorageAPIToken string) (*stream.GetSinkPayload, error) {
	var err error
	var branchID string
	{
		branchID = streamGetSinkBranchID
	}
	var sourceID string
	{
		sourceID = streamGetSinkSourceID
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var sinkID string
	{
		sinkID = streamGetSinkSinkID
		if utf8.RuneCountInString(sinkID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 1, true))
		}
		if utf8.RuneCountInString(sinkID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 48, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var storageAPIToken string
	{
		storageAPIToken = streamGetSinkStorageAPIToken
	}
	v := &stream.GetSinkPayload{}
	v.BranchID = stream.BranchIDOrDefault(branchID)
	v.SourceID = stream.SourceID(sourceID)
	v.SinkID = stream.SinkID(sinkID)
	v.StorageAPIToken = storageAPIToken

	return v, nil
}

// BuildGetSinkSettingsPayload builds the payload for the stream
// GetSinkSettings endpoint from CLI flags.
func BuildGetSinkSettingsPayload(streamGetSinkSettingsBranchID string, streamGetSinkSettingsSourceID string, streamGetSinkSettingsSinkID string, streamGetSinkSettingsStorageAPIToken string) (*stream.GetSinkSettingsPayload, error) {
	var err error
	var branchID string
	{
		branchID = streamGetSinkSettingsBranchID
	}
	var sourceID string
	{
		sourceID = streamGetSinkSettingsSourceID
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var sinkID string
	{
		sinkID = streamGetSinkSettingsSinkID
		if utf8.RuneCountInString(sinkID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 1, true))
		}
		if utf8.RuneCountInString(sinkID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 48, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var storageAPIToken string
	{
		storageAPIToken = streamGetSinkSettingsStorageAPIToken
	}
	v := &stream.GetSinkSettingsPayload{}
	v.BranchID = stream.BranchIDOrDefault(branchID)
	v.SourceID = stream.SourceID(sourceID)
	v.SinkID = stream.SinkID(sinkID)
	v.StorageAPIToken = storageAPIToken

	return v, nil
}

// BuildUpdateSinkSettingsPayload builds the payload for the stream
// UpdateSinkSettings endpoint from CLI flags.
func BuildUpdateSinkSettingsPayload(streamUpdateSinkSettingsBody string, streamUpdateSinkSettingsBranchID string, streamUpdateSinkSettingsSourceID string, streamUpdateSinkSettingsSinkID string, streamUpdateSinkSettingsStorageAPIToken string) (*stream.UpdateSinkSettingsPayload, error) {
	var err error
	var body UpdateSinkSettingsRequestBody
	{
		err = json.Unmarshal([]byte(streamUpdateSinkSettingsBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"patch\": [\n         {\n            \"key\": \"some.service.limit\",\n            \"value\": \"1m20s\"\n         }\n      ]\n   }'")
		}
		for _, e := range body.Patch {
			if e != nil {
				if err2 := ValidateSettingPatchRequestBody(e); err2 != nil {
					err = goa.MergeErrors(err, err2)
				}
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var branchID string
	{
		branchID = streamUpdateSinkSettingsBranchID
	}
	var sourceID string
	{
		sourceID = streamUpdateSinkSettingsSourceID
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var sinkID string
	{
		sinkID = streamUpdateSinkSettingsSinkID
		if utf8.RuneCountInString(sinkID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 1, true))
		}
		if utf8.RuneCountInString(sinkID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 48, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var storageAPIToken string
	{
		storageAPIToken = streamUpdateSinkSettingsStorageAPIToken
	}
	v := &stream.UpdateSinkSettingsPayload{}
	if body.Patch != nil {
		v.Patch = make([]*stream.SettingPatch, len(body.Patch))
		for i, val := range body.Patch {
			v.Patch[i] = marshalSettingPatchRequestBodyToStreamSettingPatch(val)
		}
	}
	v.BranchID = stream.BranchIDOrDefault(branchID)
	v.SourceID = stream.SourceID(sourceID)
	v.SinkID = stream.SinkID(sinkID)
	v.StorageAPIToken = storageAPIToken

	return v, nil
}

// BuildListSinksPayload builds the payload for the stream ListSinks endpoint
// from CLI flags.
func BuildListSinksPayload(streamListSinksBranchID string, streamListSinksSourceID string, streamListSinksStorageAPIToken string) (*stream.ListSinksPayload, error) {
	var err error
	var branchID string
	{
		branchID = streamListSinksBranchID
	}
	var sourceID string
	{
		sourceID = streamListSinksSourceID
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var storageAPIToken string
	{
		storageAPIToken = streamListSinksStorageAPIToken
	}
	v := &stream.ListSinksPayload{}
	v.BranchID = stream.BranchIDOrDefault(branchID)
	v.SourceID = stream.SourceID(sourceID)
	v.StorageAPIToken = storageAPIToken

	return v, nil
}

// BuildUpdateSinkPayload builds the payload for the stream UpdateSink endpoint
// from CLI flags.
func BuildUpdateSinkPayload(streamUpdateSinkBody string, streamUpdateSinkBranchID string, streamUpdateSinkSourceID string, streamUpdateSinkSinkID string, streamUpdateSinkStorageAPIToken string) (*stream.UpdateSinkPayload, error) {
	var err error
	var body UpdateSinkRequestBody
	{
		err = json.Unmarshal([]byte(streamUpdateSinkBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"type\": \"table\",\n      \"name\": \"Raw Data Sink\",\n      \"description\": \"The sink stores records to a table.\",\n      \"table\": {\n         \"mapping\": {\n            \"tableId\": \"in.c-bucket.table\",\n            \"columns\": [\n               {\n                  \"type\": \"id\",\n                  \"name\": \"id-col\",\n                  \"primaryKey\": true\n               },\n               {\n                  \"type\": \"datetime\",\n                  \"name\": \"datetime-col\"\n               },\n               {\n                  \"type\": \"ip\",\n                  \"name\": \"ip-col\"\n               },\n               {\n                  \"type\": \"headers\",\n                  \"name\": \"headers-col\"\n               },\n               {\n                  \"type\": \"body\",\n                  \"name\": \"body-col\"\n               },\n               {\n                  \"type\": \"template\",\n                  \"name\": \"template-col\",\n                  \"language\": \"jsonnet\",\n                  \"content\": \"body.foo + \\\"-\\\" + body.bar\"\n               }\n            ]\n         }\n      }\n   }'")
		}
		if body.Type != nil {
			if !(*body.Type == "table") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"table"}))
			}
		}
		if body.Name != nil {
			if utf8.RuneCountInString(*body.Name) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", *body.Name, utf8.RuneCountInString(*body.Name), 1, true))
			}
		}
		if body.Name != nil {
			if utf8.RuneCountInString(*body.Name) > 40 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", *body.Name, utf8.RuneCountInString(*body.Name), 40, false))
			}
		}
		if body.Description != nil {
			if utf8.RuneCountInString(*body.Description) > 4096 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 4096, false))
			}
		}
		if body.Table != nil {
			if err2 := ValidateTableSinkRequestBody(body.Table); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var branchID string
	{
		branchID = streamUpdateSinkBranchID
	}
	var sourceID string
	{
		sourceID = streamUpdateSinkSourceID
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var sinkID string
	{
		sinkID = streamUpdateSinkSinkID
		if utf8.RuneCountInString(sinkID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 1, true))
		}
		if utf8.RuneCountInString(sinkID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 48, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var storageAPIToken string
	{
		storageAPIToken = streamUpdateSinkStorageAPIToken
	}
	v := &stream.UpdateSinkPayload{
		Name:        body.Name,
		Description: body.Description,
	}
	if body.Type != nil {
		type_ := stream.SinkType(*body.Type)
		v.Type = &type_
	}
	if body.Table != nil {
		v.Table = marshalTableSinkRequestBodyToStreamTableSink(body.Table)
	}
	v.BranchID = stream.BranchIDOrDefault(branchID)
	v.SourceID = stream.SourceID(sourceID)
	v.SinkID = stream.SinkID(sinkID)
	v.StorageAPIToken = storageAPIToken

	return v, nil
}

// BuildDeleteSinkPayload builds the payload for the stream DeleteSink endpoint
// from CLI flags.
func BuildDeleteSinkPayload(streamDeleteSinkBranchID string, streamDeleteSinkSourceID string, streamDeleteSinkSinkID string, streamDeleteSinkStorageAPIToken string) (*stream.DeleteSinkPayload, error) {
	var err error
	var branchID string
	{
		branchID = streamDeleteSinkBranchID
	}
	var sourceID string
	{
		sourceID = streamDeleteSinkSourceID
		if utf8.RuneCountInString(sourceID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 1, true))
		}
		if utf8.RuneCountInString(sourceID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sourceId", sourceID, utf8.RuneCountInString(sourceID), 48, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var sinkID string
	{
		sinkID = streamDeleteSinkSinkID
		if utf8.RuneCountInString(sinkID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 1, true))
		}
		if utf8.RuneCountInString(sinkID) > 48 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("sinkId", sinkID, utf8.RuneCountInString(sinkID), 48, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var storageAPIToken string
	{
		storageAPIToken = streamDeleteSinkStorageAPIToken
	}
	v := &stream.DeleteSinkPayload{}
	v.BranchID = stream.BranchIDOrDefault(branchID)
	v.SourceID = stream.SourceID(sourceID)
	v.SinkID = stream.SinkID(sinkID)
	v.StorageAPIToken = storageAPIToken

	return v, nil
}

// BuildGetTaskPayload builds the payload for the stream GetTask endpoint from
// CLI flags.
func BuildGetTaskPayload(streamGetTaskBranchID string, streamGetTaskTaskID string, streamGetTaskStorageAPIToken string) (*stream.GetTaskPayload, error) {
	var err error
	var branchID int
	{
		var v int64
		v, err = strconv.ParseInt(streamGetTaskBranchID, 10, strconv.IntSize)
		branchID = int(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for branchID, must be INT")
		}
	}
	var taskID string
	{
		taskID = streamGetTaskTaskID
	}
	var storageAPIToken string
	{
		storageAPIToken = streamGetTaskStorageAPIToken
	}
	v := &stream.GetTaskPayload{}
	tmpbranchID := stream.BranchID(branchID)
	v.BranchID = &tmpbranchID
	v.TaskID = stream.TaskID(taskID)
	v.StorageAPIToken = storageAPIToken

	return v, nil
}
